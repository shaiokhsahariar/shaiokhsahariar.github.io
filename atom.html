<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Atom Model</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Three.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Orbit controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Lighting
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);

    scene.add(new THREE.AmbientLight(0x404040));

    // Nucleus
    const nucleusGeometry = new THREE.SphereGeometry(1.2, 32, 32);
    const nucleusMaterial = new THREE.MeshPhongMaterial({color: 0xff3333});
    const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
    scene.add(nucleus);

    // Electron orbit groups
    const electronOrbits = [];

    // Electron colors
    const electronColors = [0x33ccff, 0x66ff66, 0xffff66];

    // Create electrons in 3 orbits
    for (let i = 1; i <= 3; i++) {
      const orbitGroup = new THREE.Group();
      scene.add(orbitGroup);

      const orbitRadius = i * 2.5;

      const numElectrons = i * 2;

      for (let j = 0; j < numElectrons; j++) {
        const angle = (j / numElectrons) * Math.PI * 2;
        const electronGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const electronMaterial = new THREE.MeshPhongMaterial({
          color: electronColors[(i + j) % electronColors.length],
        });
        const electron = new THREE.Mesh(electronGeometry, electronMaterial);

        electron.position.set(
          orbitRadius * Math.cos(angle),
          0,
          orbitRadius * Math.sin(angle)
        );

        orbitGroup.add(electron);
      }

      orbitGroup.rotationAxis = new THREE.Vector3(
        Math.random(),
        Math.random(),
        Math.random()
      ).normalize();

      orbitGroup.rotationSpeed = 0.01 + Math.random() * 0.01;

      electronOrbits.push(orbitGroup);
    }

    // Animate
    function animate() {
      requestAnimationFrame(animate);

      electronOrbits.forEach((orbitGroup) => {
        orbitGroup.rotateOnAxis(orbitGroup.rotationAxis, orbitGroup.rotationSpeed);
      });

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
